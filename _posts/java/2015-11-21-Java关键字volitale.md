---layout: posttitle: Java关键字volitalecategory: Java相关tags: Java---对于这关键字，有个通常的说法“volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性”。对于一个volatile的i++操作，分为五个步骤：1. 从内存加载到cpu的寄存器2. 寄存器对i进行++操作3. 寄存器值写回到内存4. 执行cpu的内存屏障（Memory Barrier），防止cpu进行优化不写回，强制执行第三步骤的操作5. 使其他的cpu寄存器中的i的值无效，cpu在操作i必须重新从内存加载一次没有原子性是因为，上面的五个步骤，并不是一个原子操作，多线程并发的i++会有问题。但是只要是有一个线程更新了值，那么其他线程读到的值，都是一致的，这就叫做“可见性”。如果不是volatile变量，多线程对数据操作就没有可见性了么？那么一种情况，对于一个char（一个字节）进行++，一个线程进行++后，其他线程读到的值会有延后么？通过下面代码测试下：如果volatile有可见性的特性，那么锁也应该有可见性这个特性。这么看来，锁其实有两个维度，而volatile只有一个维度，所以，可以把volatile看作一个轻量级的锁。适用的场景典型场景就是写少，但读非常多。这样读的时候其实和普通变量很像，直接是从cpu的寄存器中读取的，也不用获取锁。因为获取锁也是比较消耗资源的，典型的如果synchronize关键字同步（如果是从偏向锁、轻量级锁）一路升到重量级锁，获取锁的时候，要进行锁的竞争，对象头中的锁的指针要不断的修改，与没有锁的volatile相比，开销很大。参考：[为什么volatile不能保证原子性而Atomic可以？](http://www.cnblogs.com/Mainz/p/3556430.html)