
## OverView ##
作为一个从C++转到Java的人，想到的STL标准的map不就一个么，底层红黑树，虽然search效率不如AVL树，但是insert和delete效率高，综合能力强，底层key还是排序的，按照key遍历顺序较快。STL也有hash map但是一直也不是标准。

Java中的map有三个，HashMap、TreeMap、LinkHashMap，java的集合框架的名字一般是 <Implementation-style><Interface>结构，前面是底层实现的数据结构，后面是接口，其他的分类可以参考Java8的集合框架的OverView-[collections-overview](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html) ，博客表格显示丑直接移步[github](https://github.com/wangzhenyagit/wangzhenyagit.github.io/blob/master/_posts/java/2017-11-23-Java%20Map.md)。


|Interface|Hash Table|Resizable Array|Balanced Tree|Linked List|HashTable+LinkedList|
|----     | ---      |----           | ---         |----       | ---                |
|Set	  |HashSet   |               |	TreeSet	   |           | LinkedHashSet      |
|List	  |          | ArrayList     |             | LinkedList|	                |
|Deque	  | 	     |ArrayDeque	 |	           |LinkedDeque|	                |
|Map	  |HashMap	 |	             |TreeMap	   |           |LinkedHashMap       |


这篇的主题是左后一行，Map接口的三种实现。


## HashMap ##
直接引用下官网的说明[Class HashMap](https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html)：

> This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.

说明了几个特点，允许null key，非线程安全，无序，而且顺序会改变。

> This implementation provides constant-time performance for the basic operations (get and put), assuming the hash function disperses the elements properly among the buckets. Iteration over collection views requires time proportional to the "capacity" of the HashMap instance (the number of buckets) plus its size (the number of key-value mappings). Thus, it's very important not to set the initial capacity too high (or the load factor too low) if iteration performance is important.

get和put操作复杂度O(1),对于Iteration操作，与HashMap的capacity有关的，capacity越大iteration越慢。

> An instance of HashMap has two parameters that affect its performance: initial capacity and load factor. The capacity is the number of buckets in the hash table, and the initial capacity is simply the capacity at the time the hash table is created. The load factor is a measure of how full the hash table is allowed to get before its capacity is automatically increased. When the number of entries in the hash table exceeds the product of the load factor and the current capacity, the hash table is rehashed (that is, internal data structures are rebuilt) so that the hash table has approximately twice the number of buckets.

由于是Hash计算，很可能冲突已经非常多了，但是hash的容量还没有满，所以需要提前对Hash进行扩容。

> As a general rule, the default load factor (.75) offers a good tradeoff between time and space costs. Higher values decrease the space overhead but increase the lookup cost (reflected in most of the operations of the HashMap class, including get and put). The expected number of entries in the map and its load factor should be taken into account when setting its initial capacity, so as to minimize the number of rehash operations. If the initial capacity is greater than the maximum number of entries divided by the load factor, no rehash operations will ever occur.

rehash的操作还是有消耗的，虽然做了优化。**最好的就是在设定hash的capacity的时候估计出大概会有多少个对象，避免出现rehash的操作。**

> If many mappings are to be stored in a HashMap instance, creating it with a sufficiently large capacity will allow the mappings to be stored more efficiently than letting it perform automatic rehashing as needed to grow the table. **Note that using many keys with the same hashCode() is a sure way to slow down performance of any hash table.** To ameliorate impact, when keys are Comparable, this class may use comparison order among keys to help break ties.

这里，如果有很多个hashCode一样的对象，或者冲突特别多的时候，Hash的效率会下降。

> A HashMap stores data into multiple singly linked lists of entries (also called buckets or bins). All the lists are registered in an array of Entry (Entry<K,V>[] array) and the default capacity of this inner array is 16.

在JAVA8之前，是通过链表的方式来解决冲突问题，如下：

<img src="http://coding-geek.com/wp-content/uploads/2015/03/internal_storage_java_hashmap.jpg"/>

在JAVA8中，对这个结构进行了优化，当一个bucket中的node大于8时，会把linked list转成红黑树的结构，会有linked list和red black tree同时存在,参考[JAVA 8 improvements](http://coding-geek.com/how-does-a-hashmap-work-in-java/#JAVA_8_improvements)。

<img src="http://coding-geek.com/wp-content/uploads/2015/03/internal_storage_java8_hashmap.jpg" />

在使用HashMap时候需要注意：

- When using a HashMap, you need to find a hash function for your keys that spreads the keys into the most possible buckets. To do so, you need to avoid hash collisions. The String Object is a good key because of it has good hash function. Integers are also good because their hashcode is their own value.
- 初始的大小很重要，最好足够大，当然要考虑内存的浪费，不产生rehash。
- 大小要是2的指数

对于第三点需要额外解释下，实现hash的算法如下：
> This index of the bucket (linked list) is generated in 3 steps by the map:
> 
> - It first gets the hashcode of the key.
> - It rehashes the hashcode to prevent against a bad hashing function from the key that would put all data in the same index (bucket) of the inner array
> - It takes the rehashed hash hashcode and bit-masks it with the length (minus 1) of the array. This operation assures that the index can’t be greater than the size of the array. You can see it as a very computationally optimized modulo function.

```
// the "rehash" function in JAVA 8 that directly takes the key
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>16);
    }
// the function that returns the index from the rehashed hash
static int indexFor(int h, int length) {
    return h & (length-1);
}
```

在最后一步，为了不超出array的大小，不是对大小取余数，而是使用了效率更高的&操作，例如如果长度16，会与15也就是1111进行&操作，这样很快地把之前的hash值变成了0-15之间的array的index。如果大小设置成了17，与16也就是0001 0000进行与操作，那结果只有两个，16和0，所有的key都会在那个两个bucket上。





[Java HashMap工作原理及实现](http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/)


