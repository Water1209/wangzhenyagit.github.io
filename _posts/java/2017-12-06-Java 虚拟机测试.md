---
layout: post
title: Java 虚拟机测试
category: Java相关
tags: 
---

### 默认的垃圾收集器？ ###

java8，使用jconsole查看，在VM概要中看到的为：
> 垃圾收集器: 
> 名称 = 'Copy', 收集 = 82, 总花费时间 = 0.129 秒  
> 垃圾收集器: 
> 名称 = 'MarkSweepCompact', 收集 = 0, 总花费时间 = 0.000 秒

新生代与老年代使用的应该都是Serial系列的，分别是Serial和SerialOld垃圾收集器。参考:[Oracle JVM Garbage Collectors Available From JDK 1.7.0_04 And After](http://www.fasterj.com/articles/oraclecollectors1.shtml)，文中也说明了如何进行设置。

> **Young generation collectors**  
> Copy (enabled with -XX:+UseSerialGC)  
> PS Scavenge (enabled with -XX:+UseParallelGC)  
> ParNew (enabled with -XX:+UseParNewGC)  
> G1 Young Generation (enabled with -XX:+UseG1GC) 
> 
> **Old generation collectors**  
> MarkSweepCompact (enabled with -XX:+UseSerialGC)  
> PS MarkSweep (enabled with -XX:+UseParallelOldGC)  
> ConcurrentMarkSweep (enabled with -XX:+UseConcMarkSweepGC)  
> G1 Mixed Generation (enabled with -XX:+UseG1GC)  

上述运行的为前台运行，启动的时候VM参数啥也没有增加，在VM启动参数加上“-client”后的使用的仍然是上述两个垃圾回收器。启动的时候如果加上"-server",再次用jconsole查看，垃圾收集器为'PS MarkSweep'和'PS Scavenge'，也就是Parallel Scavenge和Parallel Old垃圾回收器。

上述测试也表明了在jdk1.8下在client和server模式下的默认的垃圾收集器，分别是Serial的和Paralle的，client模式下，假设client端的机器不咋样，使用高效的Serial就可以了。而Server端，做的假设是一般用户是还是考虑“性价比”，追求高的吞吐量，尽量发挥硬件的性能，比较时候对延迟不敏感，特别是大量计算的场景。

而实际中，特别是互联网公司，一般是Parallel New + CMS的组合，目的是为了提高用户的体验，最短停顿优先。在ES5.6版本中默认也是用的CMS收集器。

这G1的垃圾回收器在1.7.0_04之后被正式的支持了，也有很多公司在用，比如阿里。对于这玩意调优可以参考，[Tips for Tuning the Garbage First Garbage Collector](https://www.infoq.com/articles/tuning-tips-G1-GC)

### 组合套路 ###
一般而言，这垃圾收集器也是有固定的几个套路，大概四个：

1. -XX:+UseSerialGC(young Copy and old MarkSweepCompact)，新生代与老年代都是单线程收集，适合机器比较烂，client的默认模式。
2. -XX:+UseParallelGC -XX:+UseParallelOldGC（young PS Scavenge old PS MarkSweep），新生代与老年代都是并发的方式，适合机器相对好，吞吐量优先，对等待时间不敏感，如大规模计算，server的默认模式
3. -XX:+UseConcMarkSweepGC -XX:+UseParNewGC（young ParNew old ConcurrentMarkSweep），最小等待时间优先，适合机器好，用户响应时间低的场景，一般互联网公司，B/S模式使用。
4. -XX:+UseG1GC（young G1 Young and old G1 Mixed），将来替代第三个模式的。

其他的虽然有很多可以组合的，但是很多不常用，而且有的deprecated in Java 8 and removed in Java 9。上述是主流的四个方式。